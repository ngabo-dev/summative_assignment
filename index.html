// Flower Classification Dashboard - Frontend JavaScript
// Connects to Python backend via API endpoints

class FlowerDashboard {
    constructor() {
        this.baseURL = '/api'; // Adjust based on your backend setup
        this.charts = {};
        this.uploadedFile = null;
        this.initTime = Date.now();
        
        this.init();
    }

    // Initialize the dashboard
    init() {
        console.log('üöÄ Initializing Flower Classification Dashboard...');
        
        this.setupEventListeners();
        this.loadInitialData();
        this.startPeriodicUpdates();
        
        console.log('‚úÖ Dashboard initialized successfully!');
    }

    // Setup all event listeners
    setupEventListeners() {
        // Image prediction events
        this.setupImageUpload();
        
        // Bulk upload events
        this.setupBulkUpload();
        
        // Retraining events
        this.setupRetraining();
        
        // Evaluation events
        this.setupEvaluation();
        
        console.log('üìã Event listeners configured');
    }

    // Setup image upload for prediction
    setupImageUpload() {
        const uploadZone = document.getElementById('uploadZone');
        const imageInput = document.getElementById('imageInput');
        const predictBtn = document.getElementById('predictBtn');

        // Click to upload
        uploadZone.addEventListener('click', () => {
            imageInput.click();
        });

        // Drag and drop
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleImageSelect(files[0]);
            }
        });

        // File input change
        imageInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleImageSelect(e.target.files[0]);
            }
        });

        // Predict button
        predictBtn.addEventListener('click', () => {
            this.predictImage();
        });
    }

    // Setup bulk upload functionality
    setupBulkUpload() {
        const classSelect = document.getElementById('classSelect');
        const bulkUpload = document.getElementById('bulkUpload');
        const uploadBtn = document.getElementById('uploadBtn');

        // Enable upload button when both class and files are selected
        const updateUploadBtn = () => {
            const hasClass = classSelect.value !== '';
            const hasFiles = bulkUpload.files.length > 0;
            uploadBtn.disabled = !hasClass || !hasFiles;
        };

        classSelect.addEventListener('change', updateUploadBtn);
        bulkUpload.addEventListener('change', updateUploadBtn);

        // Upload button click
        uploadBtn.addEventListener('click', () => {
            this.uploadBulkImages();
        });
    }

    // Setup retraining functionality
    setupRetraining() {
        const retrainBtn = document.getElementById('retrainBtn');
        
        retrainBtn.addEventListener('click', () => {
            this.triggerRetraining();
        });
    }

    // Setup evaluation functionality
    setupEvaluation() {
        const evaluateBtn = document.getElementById('evaluateBtn');
        
        evaluateBtn.addEventListener('click', () => {
            this.evaluateModel();
        });
    }

    // Handle image selection for prediction
    handleImageSelect(file) {
        if (!this.isValidImageFile(file)) {
            this.showNotification('Please select a valid image file', 'error');
            return;
        }

        this.uploadedFile = file;

        // Show preview
        const reader = new FileReader();
        reader.onload = (e) => {
            const previewImg = document.getElementById('previewImg');
            const imagePreview = document.getElementById('imagePreview');
            
            previewImg.src = e.target.result;
            imagePreview.classList.remove('hidden');
            
            // Enable predict button
            document.getElementById('predictBtn').disabled = false;
        };
        reader.readAsDataURL(file);
    }

    // Predict image
    async predictImage() {
        if (!this.uploadedFile) {
            this.showNotification('Please select an image first', 'error');
            return;
        }

        const predictBtn = document.getElementById('predictBtn');
        const btnText = predictBtn.querySelector('.btn-text');
        const btnLoading = predictBtn.querySelector('.btn-loading');

        try {
            // Show loading state
            btnText.classList.add('hidden');
            btnLoading.classList.remove('hidden');
            predictBtn.disabled = true;

            // Create form data
            const formData = new FormData();
            formData.append('image', this.uploadedFile);

            // Make prediction request
            const response = await fetch(`${this.baseURL}/predict`, {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                this.displayPredictionResults(result);
                this.showNotification('Prediction completed successfully!', 'success');
            } else {
                throw new Error(result.error || 'Prediction failed');
            }

        } catch (error) {
            console.error('Prediction error:', error);
            this.showNotification(`Prediction failed: ${error.message}`, 'error');
        } finally {
            // Reset button state
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            predictBtn.disabled = false;
        }
    }

    // Display prediction results
    displayPredictionResults(result) {
        const resultsDiv = document.getElementById('predictionResults');
        const contentDiv = document.getElementById('predictionContent');

        const predicted = result.predicted_class;
        const confidence = result.confidence;
        const probabilities = result.probabilities || {};

        // Get flower emoji
        const flowerEmojis = {
            'roses': 'üåπ',
            'tulips': 'üå∑',
            'sunflowers': 'üåª'
        };

        let html = `
            <div class="space-y-4">
                <div class="text-center">
                    <div class="text-6xl mb-2">${flowerEmojis[predicted] || 'üå∏'}</div>
                    <h4 class="text-2xl font-bold text-gray-800 capitalize">${predicted}</h4>
                    <p class="text-lg text-gray-600">Confidence: ${(confidence * 100).toFixed(1)}%</p>
                </div>
                
                <div class="space-y-3">
                    <h5 class="font-semibold text-gray-700">All Predictions:</h5>
        `;

        // Sort probabilities by value (highest first)
        const sortedProbs = Object.entries(probabilities)
            .sort(([,a], [,b]) => b - a);

        sortedProbs.forEach(([className, prob]) => {
            const percentage = (prob * 100).toFixed(1);
            const emoji = flowerEmojis[className] || 'üå∏';
            const isTop = className === predicted;
            
            html += `
                <div class="flex items-center justify-between p-3 rounded-lg ${isTop ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}">
                    <div class="flex items-center space-x-2">
                        <span class="text-2xl">${emoji}</span>
                        <span class="font-medium capitalize ${isTop ? 'text-blue-800' : 'text-gray-700'}">${className}</span>
                    </div>
                    <div class="text-right">
                        <span class="font-semibold ${isTop ? 'text-blue-600' : 'text-gray-600'}">${percentage}%</span>
                        <div class="w-24 h-2 bg-gray-200 rounded-full mt-1">
                            <div class="h-full bg-gradient-to-r from-blue-400 to-blue-600 rounded-full prediction-bar" data-percentage="${percentage}"></div>
                        </div>
                    </div>
                </div>
            `;
        });

        html += `
                </div>
                
                <div class="text-xs text-gray-500 text-center">
                    Processing time: ${result.processing_time?.total?.toFixed(3) || 'N/A'}s
                </div>
            </div>
        `;

        contentDiv.innerHTML = html;
        resultsDiv.classList.remove('hidden');

        // Update prediction count
        this.updatePredictionCount();
    }

    // Upload bulk images for training
    async uploadBulkImages() {
        const classSelect = document.getElementById('classSelect');
        const bulkUpload = document.getElementById('bulkUpload');
        const uploadBtn = document.getElementById('uploadBtn');
        const uploadProgress = document.getElementById('uploadProgress');
        const uploadProgressFill = document.getElementById('uploadProgressFill');
        const uploadProgressText = document.getElementById('uploadProgressText');

        const className = classSelect.value;
        const files = Array.from(bulkUpload.files);

        if (!className || files.length === 0) {
            this.showNotification('Please select a class and images to upload', 'error');
            return;
        }

        // Show loading state
        const btnText = uploadBtn.querySelector('.btn-text');
        const btnLoading = uploadBtn.querySelector('.btn-loading');
        btnText.classList.add('hidden');
        btnLoading.classList.remove('hidden');
        uploadBtn.disabled = true;

        // Show progress bar
        uploadProgress.classList.remove('hidden');
        uploadProgressFill.style.width = '0%';
        uploadProgressText.textContent = '0%';

        try {
            // Create form data
            const formData = new FormData();
            formData.append('class_name', className);
            
            files.forEach((file, index) => {
                formData.append('images', file);
            });

            // Upload with progress tracking
            const response = await this.uploadWithProgress(formData, (progress) => {
                uploadProgressFill.style.width = `${progress}%`;
                uploadProgressText.textContent = `${progress}%`;
            });

            const result = await response.json();

            if (result.success || result.uploaded_count > 0) {
                this.showNotification(
                    `Successfully uploaded ${result.uploaded_count} images to ${className}!`, 
                    'success'
                );
                
                // Update UI
                this.updateDatasetStats();
                this.updateRetrainingStatus();
                
                // Clear form
                classSelect.value = '';
                bulkUpload.value = '';
            } else {
                throw new Error(result.error || 'Upload failed');
            }

        } catch (error) {
            console.error('Upload error:', error);
            this.showNotification(`Upload failed: ${error.message}`, 'error');
        } finally {
            // Reset UI
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            uploadBtn.disabled = false;
            uploadProgress.classList.add('hidden');
        }
    }

    // Upload with progress tracking
    async uploadWithProgress(formData, onProgress) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const progress = Math.round((e.loaded * 100) / e.total);
                    onProgress(progress);
                }
            });

            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(xhr);
                } else {
                    reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                }
            });

            xhr.addEventListener('error', () => {
                reject(new Error('Network error'));
            });

            xhr.open('POST', `${this.baseURL}/upload`);
            xhr.send(formData);
        });
    }

    // Trigger model retraining
    async triggerRetraining() {
        const epochsInput = document.getElementById('epochsInput');
        const retrainBtn = document.getElementById('retrainBtn');
        const retrainingProgress = document.getElementById('retrainingProgress');
        const retrainingProgressFill = document.getElementById('retrainingProgressFill');
        const retrainingProgressText = document.getElementById('retrainingProgressText');
        const retrainingDetails = document.getElementById('retrainingDetails');

        const epochs = parseInt(epochsInput.value) || 10;

        // Confirm retraining
        if (!confirm(`Start retraining for ${epochs} epochs? This may take several minutes.`)) {
            return;
        }

        // Show loading state
        const btnText = retrainBtn.querySelector('.btn-text');
        const btnLoading = retrainBtn.querySelector('.btn-loading');
        btnText.classList.add('hidden');
        btnLoading.classList.remove('hidden');
        retrainBtn.disabled = true;

        // Show progress
        retrainingProgress.classList.remove('hidden');
        retrainingProgressFill.style.width = '0%';
        retrainingProgressText.textContent = '0%';
        retrainingDetails.textContent = 'Initializing training...';

        try {
            // Start retraining
            const response = await fetch(`${this.baseURL}/retrain`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ epochs: epochs })
            });

            const result = await response.json();

            if (result.success) {
                // Start polling for progress
                this.pollRetrainingProgress();
                
                this.showNotification('Retraining started successfully!', 'success');
            } else {
                throw new Error(result.error || 'Failed to start retraining');
            }

        } catch (error) {
            console.error('Retraining error:', error);
            this.showNotification(`Retraining failed: ${error.message}`, 'error');
            
            // Reset UI
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            retrainBtn.disabled = false;
            retrainingProgress.classList.add('hidden');
        }
    }

    // Poll retraining progress
    async pollRetrainingProgress() {
        const retrainingProgressFill = document.getElementById('retrainingProgressFill');
        const retrainingProgressText = document.getElementById('retrainingProgressText');
        const retrainingDetails = document.getElementById('retrainingDetails');
        const retrainBtn = document.getElementById('retrainBtn');

        const pollInterval = setInterval(async () => {
            try {
                const response = await fetch(`${this.baseURL}/training-status`);
                const status = await response.json();

                if (status.is_training) {
                    // Update progress
                    const progress = Math.round((status.current_epoch / status.total_epochs) * 100);
                    retrainingProgressFill.style.width = `${progress}%`;
                    retrainingProgressText.textContent = `${progress}%`;
                    retrainingDetails.textContent = `Epoch ${status.current_epoch}/${status.total_epochs} - Loss: ${status.current_loss?.toFixed(4) || 'N/A'}`;
                } else {
                    // Training completed
                    clearInterval(pollInterval);
                    
                    retrainingProgressFill.style.width = '100%';
                    retrainingProgressText.textContent = '100%';
                    retrainingDetails.textContent = 'Retraining completed!';

                    // Reset button
                    const btnText = retrainBtn.querySelector('.btn-text');
                    const btnLoading = retrainBtn.querySelector('.btn-loading');
                    btnText.classList.remove('hidden');
                    btnLoading.classList.add('hidden');
                    retrainBtn.disabled = false;

                    // Hide progress after delay
                    setTimeout(() => {
                        document.getElementById('retrainingProgress').classList.add('hidden');
                    }, 3000);

                    // Update UI
                    this.updateModelInfo();
                    this.updateRetrainingCount();
                    
                    this.showNotification('Retraining completed successfully!', 'success');
                }

            } catch (error) {
                console.error('Error polling training status:', error);
                clearInterval(pollInterval);
            }
        }, 2000); // Poll every 2 seconds
    }

    // Evaluate model
    async evaluateModel() {
        const evaluateBtn = document.getElementById('evaluateBtn');
        const evaluationResults = document.getElementById('evaluationResults');

        // Show loading state
        const btnText = evaluateBtn.querySelector('.btn-text');
        const btnLoading = evaluateBtn.querySelector('.btn-loading');
        btnText.classList.add('hidden');
        btnLoading.classList.remove('hidden');
        evaluateBtn.disabled = true;

        try {
            const response = await fetch(`${this.baseURL}/evaluate`);
            const result = await response.json();

            if (result.success) {
                this.displayEvaluationResults(result);
                this.showNotification('Model evaluation completed!', 'success');
            } else {
                throw new Error(result.error || 'Evaluation failed');
            }

        } catch (error) {
            console.error('Evaluation error:', error);
            this.showNotification(`Evaluation failed: ${error.message}`, 'error');
        } finally {
            // Reset button
            btnText.classList.remove('hidden');
            btnLoading.classList.add('hidden');
            evaluateBtn.disabled = false;
        }
    }

    // Display evaluation results
    displayEvaluationResults(result) {
        const evaluationResults = document.getElementById('evaluationResults');
        
        // Update metrics
        document.getElementById('evalAccuracy').textContent = (result.accuracy * 100).toFixed(1) + '%';
        document.getElementById('evalPrecision').textContent = (result.precision * 100).toFixed(1) + '%';
        document.getElementById('evalRecall').textContent = (result.recall * 100).toFixed(1) + '%';
        document.getElementById('evalF1').textContent = (result.f1_score * 100).toFixed(1) + '%';

        evaluationResults.classList.remove('hidden');
    }

    // Load initial data
    async loadInitialData() {
        console.log('üìä Loading initial data...');
        
        try {
            await Promise.allSettled([
                this.updateModelStatus(),
                this.updateDatasetStats(),
                this.updateModelInfo(),
                this.updateRetrainingStatus()
            ]);
        } catch (error) {
            console.error('Error loading initial data:', error);
        }
    }

    // Update model status
    async updateModelStatus() {
        try {
            const response = await fetch(`${this.baseURL}/status`);
            const status = await response.json();

            const modelStatusEl = document.getElementById('modelStatus');
            
            if (status.model_loaded) {
                modelStatusEl.innerHTML = '<i class="fas fa-circle text-green-400"></i> Ready';
            } else {
                modelStatusEl.innerHTML = '<i class="fas fa-circle text-red-400"></i> Not Ready';
            }

        } catch (error) {
            console.error('Error updating model status:', error);
            document.getElementById('modelStatus').innerHTML = '<i class="fas fa-circle text-red-400"></i> Error';
        }
    }

    // Update dataset statistics
    async updateDatasetStats() {
        try {
            const response = await fetch(`${this.baseURL}/dataset-stats`);
            const stats = await response.json();

            // Update counts
            document.getElementById('rosesCount').textContent = stats.roses || 0;
            document.getElementById('tulipsCount').textContent = stats.tulips || 0;
            document.getElementById('sunflowersCount').textContent = stats.sunflowers || 0;
            document.getElementById('trainingImages').textContent = stats.total || 0;

            // Update chart
            this.updateClassChart(stats);

        } catch (error) {
            console.error('Error updating dataset stats:', error);
        }
    }

    // Update class distribution chart
    updateClassChart(stats) {
        const ctx = document.getElementById('classChart').getContext('2d');
        
        if (this.charts.classChart) {
            this.charts.classChart.destroy();
        }

        this.charts.classChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Roses üåπ', 'Tulips üå∑', 'Sunflowers üåª'],
                datasets: [{
                    data: [stats.roses || 0, stats.tulips || 0, stats.sunflowers || 0],
                    backgroundColor: [
                        '#ef4444', // Red for roses
                        '#eab308', // Yellow for tulips
                        '#f97316'  // Orange for sunflowers
                    ],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            padding: 20,
                            usePointStyle: true
                        }
                    }
                }
            }
        });
    }

    // Update model information
    async updateModelInfo() {
        try {
            const response = await fetch(`${this.baseURL}/model-info`);
            const info = await response.json();

            document.getElementById('modelArchitecture').textContent = info.architecture || 'CNN';
            document.getElementById('modelParams').textContent = this.formatNumber(info.total_params) || '--';
            document.getElementById('lastTraining').textContent = info.last_training || '--';

        } catch (error) {
            console.error('Error updating model info:', error);
        }
    }

    // Update retraining status
    async updateRetrainingStatus() {
        try {
            const response = await fetch(`${this.baseURL}/retraining-status`);
            const status = await response.json();

            const readinessText = document.getElementById('readinessText');
            const pendingImagesCount = document.getElementById('pendingImagesCount');
            const retrainBtn = document.getElementById('retrainBtn');

            // Update pending images count
            const totalPending = Object.values(status.pending_data || {}).reduce((sum, count) => sum + count, 0);
            pendingImagesCount.textContent = totalPending;

            // Update readiness status
            if (status.ready_for_retraining) {
                readinessText.innerHTML = '<span class="text-green-600">‚úÖ Ready</span>';
                retrainBtn.disabled = false;
            } else {
                readinessText.innerHTML = '<span class="text-yellow-600">‚ö†Ô∏è Need more data</span>';
                retrainBtn.disabled = true;
            }

        } catch (error) {
            console.error('Error updating retraining status:', error);
        }
    }

    // Update prediction count
    updatePredictionCount() {
        const currentCount = parseInt(document.getElementById('predictionsCount').textContent) || 0;
        document.getElementById('predictionsCount').textContent = currentCount + 1;
    }

    // Update retraining count
    updateRetrainingCount() {
        const currentCount = parseInt(document.getElementById('retrainingCount').textContent) || 0;
        document.getElementById('retrainingCount').textContent = currentCount + 1;
    }

    // Start periodic updates
    startPeriodicUpdates() {
        // Update uptime every second
        setInterval(() => {
            const uptime = Date.now() - this.initTime;
            document.getElementById('uptimeDisplay').textContent = this.formatUptime(uptime);
        }, 1000);

        // Update stats every 30 seconds
        setInterval(() => {
            this.updateDatasetStats();
            this.updateRetrainingStatus();
        }, 30000);

        // Update model status every 60 seconds
        setInterval(() => {
            this.updateModelStatus();
        }, 60000);
    }

    // Utility functions
    isValidImageFile(file) {
        const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/bmp', 'image/tiff'];
        return validTypes.includes(file.type);
    }

    formatNumber(num) {
        if (num >= 1000000) {
            return (num / 1000000).toFixed(1) + 'M';
        } else if (num >= 1000) {
            return (num / 1000).toFixed(1) + 'K';
        }
        return num?.toString() || '--';
    }

    formatUptime(ms) {
        const seconds = Math.floor(ms / 1000);
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
            return `${minutes}m ${secs}s`;
        } else {
            return `${secs}s`;
        }
    }

    // Show notification
    showNotification(message, type = 'info') {
        const container = document.getElementById('notifications');
        
        const notification = document.createElement('div');
        notification.className = `notification p-4 rounded-lg shadow-lg text-white transform transition-transform ${
            type === 'success' ? 'bg-green-500' : 
            type === 'error' ? 'bg-red-500' : 
            type === 'warning' ? 'bg-yellow-500' : 
            'bg-blue-500'
        }`;
        
        const icon = type === 'success' ? 'check-circle' : 
                    type === 'error' ? 'exclamation-circle' : 
                    type === 'warning' ? 'exclamation-triangle' : 
                    'info-circle';

        notification.innerHTML = `
            <div class="flex items-center">
                <i class="fas fa-${icon} mr-3"></i>
                <span>${message}</span>
                <button class="ml-auto pl-3" aria-label="Close notification" onclick="this.parentElement.parentElement.remove()">
                    <span class="sr-only">Close</span>
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;

        container.appendChild(notification);

        // Show notification
        setTimeout(() => {
            notification.classList.add('show');
        }, 100);

        // Auto remove after 5 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    }
}

// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.flowerDashboard = new FlowerDashboard();
    // Set prediction bar widths after DOM update
    setTimeout(() => {
        document.querySelectorAll('.prediction-bar').forEach(bar => {
            const percent = bar.getAttribute('data-percentage');
            bar.style.width = percent + '%';
        });
    }, 0);
    console.log('üå∏ Flower Classification Dashboard is ready!');
});